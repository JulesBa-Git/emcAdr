# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Convert ATC Code for each patients to the corresponding DFS number of the ATC tree 
#'
#'@param tree : ATC tree (we assume that there is a column 'ATCCode' )
#'@param patients : patients observations, for each patient we got a string containing every medication he takes/took
#'@export
ATCtoNumeric <- function(patients, tree) {
    invisible(.Call(`_emcAdr_ATCtoNumeric`, patients, tree))
}

#'Convert the histogram returned by the DistributionApproximation function, to a real number ditribution
#'(that can be used in a test for example) 
#'
#'@param vec : distribution returned by the DistributionAproximationFunction
#'@export
histogramToDitribution <- function(vec) {
    .Call(`_emcAdr_histogramToDitribution`, vec)
}

incorporateOustandingRRToDistribution <- function(outstandingRR, RRmax) {
    .Call(`_emcAdr_incorporateOustandingRRToDistribution`, outstandingRR, RRmax)
}

#'The true RR distribution of cocktail of size 3
NULL

#'Function used to compare diverse metrics used in Disproportionality analysis
NULL

#'The Evolutionary MCMC method that runs the random walk
#'
#'@param n : number of step 
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param nbResults : number of results returned (best RR individuals), 5 by default
#'@param nbIndividuals : number on individuals in the population, 5 by default
#'@param startingIndividuals : starting individuals, randomly initialized by default 
#'(same form as the observations)
#'@param startingTemperatures : starting temperatures, randomly initialized by default
#'@param P_type1/P_type2/P_crossover : probability to operate respectively type1 mutation, type2 mutation and crossover. Note :
#'the probability to operate the swap is then 1 - sum(P_type1,P_type2,P_crossover). The sum must be less or equal to 1. 
#'@param alpha : a hyperparameter allowing us to manage to probability of adding a drug to the cocktail. The probability
#' to add a drug to the cocktail is the following : \eqn{\frac12}{\alpha/n} Where n is the original size of the cocktail. 1 is the default value.
#'
#'@return if no problem return an R List with : the distribution of RR we've met; bests individuals and the corresponding RRs. Otherwise the list is empty
#'@export
EMC <- function(n, ATCtree, observations, P_type1 = .25, P_type2 = .25, P_crossover = .25, nbIndividuals = 5L, nbResults = 5L, alpha = 1, startingIndividuals = NULL, startingTemperatures = NULL) {
    .Call(`_emcAdr_EMC`, n, ATCtree, observations, P_type1, P_type2, P_crossover, nbIndividuals, nbResults, alpha, startingIndividuals, startingTemperatures)
}

#'The Evolutionary MCMC method that runs the random walk on a single cocktail
#'
#'@param epochs : number of step 
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param temperature : starting temperature, default = 1
#'@param nbResults : Number of returned solution (Cocktail of size Smax), 5 by default
#'@param Smax : Size of the cocktail we approximate the distribution from
#'@param p_type1: probability to operate type1 mutation. Note :
#'the probability to operate the type 2 mutation is then 1 - P_type1. P_type1 must be in [0;1]. 
#'@param beta : filter the minimum number of patients that must have taken the 
#'cocktail for it to be considered 'significant', default is 4
#'@param Upper bound of the considered Metric. 
#'@param num_thread : Number of thread to run in parallel
#'
#'@return if no problem return an array of the approximation of the RR distribution : the distribution of RR we've met; Otherwise the list is empty
#'@export
DistributionApproximation <- function(epochs, ATCtree, observations, temperature = 1L, nbResults = 5L, Smax = 2L, p_type1 = .01, beta = 4L, max_Metric = 100L, num_thread = 1L) {
    .Call(`_emcAdr_DistributionApproximation`, epochs, ATCtree, observations, temperature, nbResults, Smax, p_type1, beta, max_Metric, num_thread)
}

#'Genetic algorithm, trying to reach the best cocktail (the one which maximize
#'the fitness function, Related Risk in our case)
#'
#'@param epochs : number of step 
#'@param nbIndividuals : size of the popultation
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'@param diversity : enable the diversity mechanism of the algorithm
#' (favor the diversity of cocktail in the population)
#'@param p_crossover: probability to operate a crossover on the crossover phase.
#'@param p_mutation: probability to operate a mutation after the crossover phase.
#'@param nbElite : number of best individual we keep from generation to generation
#'@param tournamentSize : size of the tournament (select the best individual be tween tournamentSize individuals) 
#'
#'@return if no problem return the best cocktail we found (according to the fitness function which is the Relative Risk)
#'@export
GeneticAlgorithm <- function(epochs, nbIndividuals, ATCtree, observations, num_thread = 1L, diversity = FALSE, p_crossover = .80, p_mutation = .01, nbElite = 0L, tournamentSize = 2L, alpha = 1, summary = TRUE) {
    .Call(`_emcAdr_GeneticAlgorithm`, epochs, nbIndividuals, ATCtree, observations, num_thread, diversity, p_crossover, p_mutation, nbElite, tournamentSize, alpha, summary)
}

#'The true RR distribution of cocktail of size 2
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@return the RR distribution among size 2 cocktail
#'@export
trueDistributionSizeTwoCocktail <- function(ATCtree, observations, beta, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeTwoCocktail`, ATCtree, observations, beta, num_thread)
}

trueDistributionSizeThreeCocktail <- function(ATCtree, observations, beta, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeThreeCocktail`, ATCtree, observations, beta, num_thread)
}

MetricCalc <- function(cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread = 1L) {
    .Call(`_emcAdr_MetricCalc`, cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread)
}

computeMetrics <- function(df, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_computeMetrics`, df, ATCtree, observations, num_thread)
}

hyperparam_test_genetic_algorithm <- function(epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path = "./", num_thread = 1L) {
    invisible(.Call(`_emcAdr_hyperparam_test_genetic_algorithm`, epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path, num_thread))
}

