# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Convert ATC Code for each patients to the corresponding DFS number of the ATC tree 
#'
#'@param tree : ATC tree (we assume that there is a column 'ATCCode' )
#'@param patients : patients observations, for each patient we got a string containing every medication he takes/took
#'@export
ATCtoNumeric <- function(patients, tree) {
    invisible(.Call(`_emcAdr_ATCtoNumeric`, patients, tree))
}

#'Convert the histogram returned by the DistributionApproximation function, to a real number ditribution
#'(that can be used in a test for example) 
#'
#'@param vec : distribution returned by the DistributionAproximationFunction
#'@export
histogramToDitribution <- function(vec) {
    .Call(`_emcAdr_histogramToDitribution`, vec)
}

incorporateOustandingRRToDistribution <- function(outstandingRR, RRmax) {
    .Call(`_emcAdr_incorporateOustandingRRToDistribution`, outstandingRR, RRmax)
}

#' Used to add the p_value to each cocktail of a csv_file that is an
#' output of the genetic algorithm
#' @param distribution_outputs A list of distribution of cocktails of different sizes
#' in order to compute the p_value for multiple cocktail sizes
#' @param filename The file name of the .csv file containing the output
#' @param filtered_distribution Does the p-values have to be computed using filtered distribution
#' or normal distribution (filtered distribution by default)
#' @param sep The separator used in the csv file (';' by default)
p_value_csv_file <- function(distribution_outputs, filename, filtred_distribution = TRUE, sep = ";") {
    invisible(.Call(`_emcAdr_p_value_csv_file`, distribution_outputs, filename, filtred_distribution, sep))
}

#' Function used to convert your genetic algorithm results that are stored into 
#' a .csv file to a Data structure that can be used by the clustering algorithm
#' @param ATC_name the ATC_name column of the ATC tree
#' @param filename Name of the file where the results are located
#' @param sep the separator to use when opening the csv file (';' by default)
#' @return An R List that can be used by other algorithms (e.g. clustering algorithm)
csv_to_population <- function(ATC_name, filename, sep = ";") {
    .Call(`_emcAdr_csv_to_population`, ATC_name, filename, sep)
}

#'The true RR distribution of cocktail of size 3
NULL

#'Function used to compare diverse metrics used in Disproportionality analysis
NULL

#'Convert ATC index used in the algorithm to name of the node in the ATC tree
NULL

#'The Evolutionary MCMC method that runs the random walk
#'
#'@param n : number of step 
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param nbResults : number of results returned (best RR individuals), 5 by default
#'@param nbIndividuals : number on individuals in the population, 5 by default
#'@param startingIndividuals : starting individuals, randomly initialized by default 
#'(same form as the observations)
#'@param startingTemperatures : starting temperatures, randomly initialized by default
#'@param P_type1/P_type2/P_crossover : probability to operate respectively type1 mutation, type2 mutation and crossover. Note :
#'the probability to operate the swap is then 1 - sum(P_type1,P_type2,P_crossover). The sum must be less or equal to 1. 
#'@param alpha : a hyperparameter allowing us to manage to probability of adding a drug to the cocktail. The probability
#' to add a drug to the cocktail is the following : \eqn{\frac12}{\alpha/n} Where n is the original size of the cocktail. 1 is the default value.
#'
#'@return if no problem return an R List with : the distribution of RR we've met; bests individuals and the corresponding RRs. Otherwise the list is empty
#'@export
EMC <- function(n, ATCtree, observations, P_type1 = .25, P_type2 = .25, P_crossover = .25, nbIndividuals = 5L, nbResults = 5L, alpha = 1, startingIndividuals = NULL, startingTemperatures = NULL) {
    .Call(`_emcAdr_EMC`, n, ATCtree, observations, P_type1, P_type2, P_crossover, nbIndividuals, nbResults, alpha, startingIndividuals, startingTemperatures)
}

#'The Evolutionary MCMC method that runs the random walk on a single cocktail
#'
#'@param epochs : number of step 
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param temperature : starting temperature, default = 1
#'@param nbResults : Number of returned solution (Cocktail of size Smax), 5 by default
#'@param Smax : Size of the cocktail we approximate the distribution from
#'@param p_type1: probability to operate type1 mutation. Note :
#'the probability to operate the type 2 mutation is then 1 - P_type1. P_type1 must be in [0;1]. 
#'@param beta : filter the minimum number of patients that must have taken the 
#'cocktail for it to be considered 'significant', default is 4
#'@param Upper bound of the considered Metric. 
#'@param num_thread : Number of thread to run in parallel
#'
#'@return if no problem return an array of the approximation of the RR distribution : the distribution of RR we've met; Otherwise the list is empty
#'@export
DistributionApproximation <- function(epochs, ATCtree, observations, temperature = 1L, nbResults = 5L, Smax = 2L, p_type1 = .01, beta = 4L, max_Metric = 100L, num_thread = 1L) {
    .Call(`_emcAdr_DistributionApproximation`, epochs, ATCtree, observations, temperature, nbResults, Smax, p_type1, beta, max_Metric, num_thread)
}

#'Genetic algorithm, trying to reach the best cocktail (the one which maximize
#'the fitness function, Related Risk in our case)
#'
#'@param epochs : number of step 
#'@param nbIndividuals : size of the popultation
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observation : real observation of the ADR based on the medications of each real patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'@param diversity : enable the diversity mechanism of the algorithm
#' (favor the diversity of cocktail in the population)
#'@param p_crossover: probability to operate a crossover on the crossover phase.
#'@param p_mutation: probability to operate a mutation after the crossover phase.
#'@param nbElite : number of best individual we keep from generation to generation
#'@param tournamentSize : size of the tournament (select the best individual be tween tournamentSize individuals) 
#'
#'@return if no problem return the best cocktail we found (according to the fitness function which is the Relative Risk)
#'@export
GeneticAlgorithm <- function(epochs, nbIndividuals, ATCtree, observations, num_thread = 1L, diversity = FALSE, p_crossover = .80, p_mutation = .01, nbElite = 0L, tournamentSize = 2L, alpha = 1, summary = TRUE) {
    .Call(`_emcAdr_GeneticAlgorithm`, epochs, nbIndividuals, ATCtree, observations, num_thread, diversity, p_crossover, p_mutation, nbElite, tournamentSize, alpha, summary)
}

#'The true distribution of drugs
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param obervations : population of patients on which we want to compute the risk distribution
#'@param beta : minimum number of cocktail takers 
#'@param max_risk : maximum risk, at which point the risk is considered exceptional (outliers)
#'
#'@return the risk distribution among drugs
#'@export
trueDistributionDrugs <- function(ATCtree, observations, beta, max_risk = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionDrugs`, ATCtree, observations, beta, max_risk, num_thread)
}

#'The true distribution of size 2 cocktails
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param obervations : population of patients on which we want to compute the risk distribution
#'@param beta : minimum number of cocktail takers 
#'@param max_risk : maximum risk, at which point the risk is considered exceptional (outliers)
#'
#'@return the risk distribution among size 2 cocktails
#'@export
trueDistributionSizeTwoCocktail <- function(ATCtree, observations, beta, max_risk = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeTwoCocktail`, ATCtree, observations, beta, max_risk, num_thread)
}

trueDistributionSizeThreeCocktail <- function(ATCtree, observations, beta, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeThreeCocktail`, ATCtree, observations, beta, num_thread)
}

MetricCalc <- function(cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread = 1L) {
    .Call(`_emcAdr_MetricCalc`, cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread)
}

computeMetrics <- function(df, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_computeMetrics`, df, ATCtree, observations, num_thread)
}

hyperparam_test_genetic_algorithm <- function(epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path = "./", num_thread = 1L) {
    invisible(.Call(`_emcAdr_hyperparam_test_genetic_algorithm`, epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path, num_thread))
}

analyse_resultats <- function(reponses, input_filename, repetition, ATCtree) {
    invisible(.Call(`_emcAdr_analyse_resultats`, reponses, input_filename, repetition, ATCtree))
}

analyse_resultats_2 <- function(reponses, input_filename, repetition, ATCtree, have_solution) {
    invisible(.Call(`_emcAdr_analyse_resultats_2`, reponses, input_filename, repetition, ATCtree, have_solution))
}

#'Print every cocktail found during the genetic algorithm 
#'
#'@param input_filenames : A List containing filename of hyperparam_test_genetic_algorithm output file
#'@param ATCtree : The ATC tree
#'@param csv_filename : Name of the output file
#'
#'@export
print_csv <- function(input_filenames, observations, repetition, ATCtree, csv_filename = "solutions.csv") {
    invisible(.Call(`_emcAdr_print_csv`, input_filenames, observations, repetition, ATCtree, csv_filename))
}

get_dissimilarity_from_list <- function(genetic_results, ATCtree) {
    .Call(`_emcAdr_get_dissimilarity_from_list`, genetic_results, ATCtree)
}

get_dissimilarity <- function(filename, ATCtree, normalization = TRUE) {
    .Call(`_emcAdr_get_dissimilarity`, filename, ATCtree, normalization)
}

get_answer_class <- function(filename, answer) {
    .Call(`_emcAdr_get_answer_class`, filename, answer)
}

ATC_idx_to_string <- function(patients, ATCName) {
    .Call(`_emcAdr_ATC_idx_to_string`, patients, ATCName)
}

dmvnrm_arma <- function(X, mean, sigma_k, w) {
    .Call(`_emcAdr_dmvnrm_arma`, X, mean, sigma_k, w)
}

FWD_EM <- function(X, K, eps, w_i, max_steps) {
    .Call(`_emcAdr_FWD_EM`, X, K, eps, w_i, max_steps)
}

