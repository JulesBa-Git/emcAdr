# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Convert ATC Code for each patients to the corresponding DFS number of the ATC tree 
#'
#'@param tree : ATC tree (we assume that there is a column 'ATCCode' )
#'@param patients : patients observations, for each patient we got a string 
#'containing taken medications
#'@export
ATCtoNumeric <- function(patients, tree) {
    invisible(.Call(`_emcAdr_ATCtoNumeric`, patients, tree))
}

#'Convert the histogram returned by the DistributionApproximation function, to a real number distribution
#'(that can be used in a test for example) 
#'
#'@param vec : distribution returned by the DistributionAproximationFunction
#'
#'@return A vector containing sampled risk during the MCMC algorithm 
#'@export
histogramToDitribution <- function(vec) {
    .Call(`_emcAdr_histogramToDitribution`, vec)
}

#' Output the outstanding score (Outstanding_score) outputed by the MCMC algorithm
#' in a special format
#' 
#' @param oustanding_score : Outstanding_score outputed by MCMC algorithm to be converted
#' to the ScoreDistribution format
#' @param max_score : max_score parameter used during the MCMC algorithm
#' 
#' @return outstanding_score in a format compatible with MCMC algorithm output
#' @export
OustandingScoreToDistribution <- function(outstanding_score, max_score) {
    .Call(`_emcAdr_OustandingScoreToDistribution`, outstanding_score, max_score)
}

#' Used to add the p_value to each cocktail of a csv_file that is an
#' output of the genetic algorithm
#' @param distribution_outputs A list of distribution of cocktails of different sizes
#' in order to compute the p_value for multiple cocktail sizes
#' @param filename The file name of the .csv file containing the output
#' @param filtered_distribution Does the p-values have to be computed using filtered distribution
#' or normal distribution (filtered distribution by default)
#' @param sep The separator used in the csv file (';' by default)
#' @export
p_value_csv_file <- function(distribution_outputs, filename, filtred_distribution = TRUE, sep = ";") {
    invisible(.Call(`_emcAdr_p_value_csv_file`, distribution_outputs, filename, filtred_distribution, sep))
}

#' Function used to convert your genetic algorithm results that are stored into 
#' a .csv file to a Data structure that can be used by the clustering algorithm
#' @param ATC_name the ATC_name column of the ATC tree
#' @param filename Name of the file where the results are located
#' @param sep the separator to use when opening the csv file (';' by default)
#' @return An R List that can be used by other algorithms (e.g. clustering algorithm)
#' @export
csv_to_population <- function(ATC_name, filename, sep = ";") {
    .Call(`_emcAdr_csv_to_population`, ATC_name, filename, sep)
}

#' Function used to convert a string vector of drugs in form "drug1:drug2" to 
#' a vector of index of the ATC tree ex: c(ATC_index(drug1), ATC_index(drugs2))
#' @param ATC_name the ATC_name column of the ATC tree
#' @param lines A string vector of drugs cocktail in the form "drug1:drug2:...:drug_n"
#' @return An R List that can be used by other algorithms (e.g. clustering algorithm)
#' @export
string_list_to_int_cocktails <- function(ATC_name, lines) {
    .Call(`_emcAdr_string_list_to_int_cocktails`, ATC_name, lines)
}

#' Function used to convert integer cocktails (like the one outputed by the distributionApproximation function)
#' to string cocktail in order to make them more readable
#' 
#' @param cocktails cocktails vector to be converted (index in the ATC tree)
#' @param ATC_name The ATC_name column of the ATC tree
#' 
#' @return The name of integer cocktails in cocktails
#' @export
int_cocktail_to_string_cocktail <- function(cocktails, ATC_name) {
    .Call(`_emcAdr_int_cocktail_to_string_cocktail`, cocktails, ATC_name)
}

#'The MCMC method that runs the random walk on a single cocktail in order to estimate the distribution of score among cocktails of size Smax.
#'
#'@param epochs : number of steps for the MCMC algorithm
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root, also see on the github repo for an example)
#'@param observations : real observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param temperature : starting temperature, default = 1 (denoted T in the article)
#'@param nbResults : Number of returned solution (Cocktail of size Smax with the best oberved score during the run), 5 by default
#'@param Smax : Size of the cocktail we approximate the distribution from
#'@param p_type1: probability to operate type1 mutation. Note :
#'the probability to operate the type 2 mutation is then 1 - P_type1. P_type1 must be in [0;1]. Default is .01
#'@param beta : filter the minimum number of patients that must have taken the 
#'cocktail for his risk to be taken into account in the DistributionScoreBeta default is 4
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 500
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return I no problem, return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - OutstandingScore : An array of the score greater than max_score,
#' - bestCockatils : the nbResults bests cocktails encountered during the run.
#' - bestScore : Score corresponding to the bestCocktails.
#' - FilteredDistribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - bestCocktailsBeta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - bestScoreBeta : Score corresponding to the bestCocktailsBeta.
#' - cocktailSize : Smax parameter used during the run.
#'; Otherwise the list is empty
#'@export
DistributionApproximation <- function(epochs, ATCtree, observations, temperature = 1L, nbResults = 5L, Smax = 2L, p_type1 = .01, beta = 4L, max_score = 500L, num_thread = 1L, verbose = FALSE) {
    .Call(`_emcAdr_DistributionApproximation`, epochs, ATCtree, observations, temperature, nbResults, Smax, p_type1, beta, max_score, num_thread, verbose)
}

#'Genetic algorithm, trying to reach riskiest cocktails (the ones which maximize
#'the fitness function, Hypergeometric score in our case)
#'
#'@param epochs : number of step or the algorithm 
#'@param nbIndividuals : size of the population
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : real observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'@param diversity : enable the diversity mechanism of the algorithm
#' (favor the diversity of cocktail in the population),  default is false
#'@param p_crossover: probability to operate a crossover on the crossover phase. Default is 80\%
#'@param p_mutation: probability to operate a mutation after the crossover phase. Default is 1\%
#'@param nbElite : number of best individual we keep from generation to generation. Default is 0
#'@param tournamentSize : size of the tournament (select the best individual 
#'between tournamentSize sampled individuals) 
#'
#'@return If no problem, return a List :
#' - meanFitnesses : The mean score of the population at each epochs of the algorithm.
#' - BestFitnesses : The best score of the population at each epochs of the algorithm.
#' - FinalPopulation : The final population of the algorithm when finished (medications
#' and corresponding scores)
#'@export
GeneticAlgorithm <- function(epochs, nbIndividuals, ATCtree, observations, num_thread = 1L, diversity = FALSE, p_crossover = .80, p_mutation = .01, nbElite = 0L, tournamentSize = 2L, alpha = 1, summary = TRUE) {
    .Call(`_emcAdr_GeneticAlgorithm`, epochs, nbIndividuals, ATCtree, observations, num_thread, diversity, p_crossover, p_mutation, nbElite, tournamentSize, alpha, summary)
}

#'The true distribution of the score among every single nodes of the ATC
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param beta : minimum number of person taking the cocktails in order to consider it
#'in the beta score distribution 
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 1000
#'@param nbResults : Number of returned solution (Cocktail with the
#' best oberved score during the run), 100 by default
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return Return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - Filtered_score_distribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - Outstanding_score : An array of the score greater than max_score,
#' - Best_cocktails : the nbResults bests cocktails encountered during the run.
#' - Best_cocktails_beta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - Best_scores : Score corresponding to the Best_cocktails.
#' - Best_scores_beta : Score corresponding to the Best_cocktails_beta.
#'@export
trueDistributionDrugs <- function(ATCtree, observations, beta, max_score = 1000L, nbResults = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionDrugs`, ATCtree, observations, beta, max_score, nbResults, num_thread)
}

#'The true distribution of the score among every size-two cocktails
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param beta : minimum number of person taking the cocktails in order to consider it
#'in the beta score distribution 
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 1000
#'@param nbResults : Number of returned solution (Cocktail with the
#' best oberved score during the run), 100 by default
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return Return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - Filtered_score_distribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - Outstanding_score : An array of the score greater than max_score,
#' - Best_cocktails : the nbResults bests cocktails encountered during the run.
#' - Best_cocktails_beta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - Best_scores : Score corresponding to the Best_cocktails.
#' - Best_scores_beta : Score corresponding to the Best_cocktails_beta.
#'@export
trueDistributionSizeTwoCocktail <- function(ATCtree, observations, beta, max_score = 100L, nbResults = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeTwoCocktail`, ATCtree, observations, beta, max_score, nbResults, num_thread)
}

#'Function used to compute the Relative Risk on a list of cocktails
#'
#'@param cocktails : A list containing cocktails in the form of vector of integers (ATC index)
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#' 
#'@return RR score among "cocktails" parameters
#'@export
compute_RR_on_list <- function(cocktails, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_compute_RR_on_list`, cocktails, ATCtree, observations, num_thread)
}

#'Function used to compute the Hypergeometric score on a list of cocktails
#'
#'@param cocktails : A list containing cocktails in the form of vector of integers (ATC index)
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#' 
#'@return Hypergeometric score among "cocktails" parameters
#'@export
compute_hypergeom_on_list <- function(cocktails, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_compute_hypergeom_on_list`, cocktails, ATCtree, observations, num_thread)
}

#'Function used in the reference article to compare diverse Disproportionality Analysis metrics 
#'
#'@param CocktailList : A list of cocktails on which the Disproportionality analysis metrics should be computed
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return Multiple DA metrics computed on CocktailList cocktails
#'@export
computeMetrics_size2 <- function(CocktailList, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_computeMetrics_size2`, CocktailList, ATCtree, observations, num_thread)
}

#' This function can be used in order to try different set of parameters for the genetic
#' algorithm in a convenient way. This will run each combination of mutation_rate,
#' nb_elite and alphas possible nb_test_desired times. For each sets of parameters,
#' results will be saved in a file named according to the set of parameter. One
#' can regroup the results of each run in a csv file by using the print_csv function
#' specifying the names of each file that needs to be treated and the number of 
#' performed runs on each parameter set
#' 
#' @param epochs : the number of epochs for the genetic algorithm
#' @param nb_individuals : the size of the population in the genetic algorithm
#' @param ATCtree : ATC tree with upper bound of the DFS (without the root)
#' @param observations : observation of the AE based on the medications of each patients
#' (a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#' @param nb_test_desired : number of genetic algorithm runs on each sets of parameters
#' @param mutation_rate : a vector with each mutation_rate to be tested
#' @param nb_elite : a vector with each nb_elite to be tested
#' @param alphas : a vector with each alphas to be tested
#' @param path : the path where the resulting files should be written
#' @param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
hyperparam_test_genetic_algorithm <- function(epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path = "./", num_thread = 1L) {
    invisible(.Call(`_emcAdr_hyperparam_test_genetic_algorithm`, epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path, num_thread))
}

#'Print every cocktails found during the genetic algorithm when used with the 
#'hyperparam_test_genetic_algorithm function. This enables to condense the solutions 
#'found in each files by collapsing similar cocktail in a single row by cocktail.
#'
#'
#' @param input_filenames : A List containing filename of hyperparam_test_genetic_algorithm output file
#' @param observations : observation of the AE based on the medications of each patients
#' (a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#' @param repetition : The parameter nb_test_desired used in the hyperparam test function
#' @param ATCtree : ATC tree with upper bound of the DFS (without the root)
#' @param csv_filename : Name of the output file, "solutions.csv" by default
#'
#'@export
print_csv <- function(input_filenames, observations, repetition, ATCtree, csv_filename = "solutions.csv") {
    invisible(.Call(`_emcAdr_print_csv`, input_filenames, observations, repetition, ATCtree, csv_filename))
}

#' Recover the square matrix of distance between cocktails where the index (i,j)
#' of the matrix is the distance between cocktails i and j in the genetic_results
#' list. 
#' @param genetic_results the List returned by the genetic algorithm.
#' @param ATCtree : ATC tree with upper bound of the DFS (without the root)
#' @param normalization : Do we keep the distance between cocktail in the range [0;1] ? 
#' 
#' @return The square matrix of distances between cocktails
get_dissimilarity_from_genetic_results <- function(genetic_results, ATCtree, normalization) {
    .Call(`_emcAdr_get_dissimilarity_from_genetic_results`, genetic_results, ATCtree, normalization)
}

#' Recover the square matrix of distance between cocktails where the index (i,j)
#' of the matrix is the distance between cocktails i and j in the csv file containing
#' results of genetic algorithm
#' 
#' @param filename : the name of the file returned by the print_csv function.
#' @param ATCtree : ATC tree with upper bound of the DFS (without the root)
#' @param normalization : Do we keep the distance between cocktail in the range [0;1] ? 
#' 
#' @return The square matrix of distances between cocktails
get_dissimilarity_from_csv_file <- function(filename, ATCtree, normalization = TRUE) {
    .Call(`_emcAdr_get_dissimilarity_from_csv_file`, filename, ATCtree, normalization)
}

#' Recover the square matrix of distance between cocktails where the index (i,j)
#' of the matrix is the distance between cocktails i and j in an arbitrary
#' cocktail list
#' 
#' @param cocktails : A list of cocktails in the form of a vector of integer
#' @param ATCtree : ATC tree with upper bound of the DFS (without the root)
#' @param normalization : Do we keep the distance between cocktail in the range [0;1] ? 
#' 
#' @return The square matrix of distances between cocktails
get_dissimilarity_from_cocktail_list <- function(cocktails, ATCtree, normalization = TRUE) {
    .Call(`_emcAdr_get_dissimilarity_from_cocktail_list`, cocktails, ATCtree, normalization)
}

