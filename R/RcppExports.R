# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Convert ATC Code for each patients to the corresponding DFS number of the ATC tree 
#'
#'@param tree : ATC tree (we assume that there is a column 'ATCCode' )
#'@param patients : patients observations, for each patient we got a string 
#'containing taken medications
#'@export
ATCtoNumeric <- function(patients, tree) {
    invisible(.Call(`_emcAdr_ATCtoNumeric`, patients, tree))
}

#'Convert the histogram returned by the DistributionApproximation function, to a real number distribution
#'(that can be used in a test for example) 
#'
#'@param vec : distribution returned by the DistributionAproximationFunction
#'
#'@return A vector containing sampled risk during the MCMC algorithm 
#'@export
histogramToDitribution <- function(vec) {
    .Call(`_emcAdr_histogramToDitribution`, vec)
}

#' Output the outstanding score (Outstanding_score) outputed by the MCMC algorithm
#' in a special format
#' 
#' @param oustanding_score : Outstanding_score outputed by MCMC algorithm to be converted
#' to the ScoreDistribution format
#' @param max_score : max_score parameter used during the MCMC algorithm
#' 
#' @return outstanding_score in a format compatible with MCMC algorithm output
#' @export
OustandingScoreToDistribution <- function(outstanding_score, max_score) {
    .Call(`_emcAdr_OustandingScoreToDistribution`, outstanding_score, max_score)
}

#' Used to add the p_value to each cocktail of a csv_file that is an
#' output of the genetic algorithm
#' @param distribution_outputs A list of distribution of cocktails of different sizes
#' in order to compute the p_value for multiple cocktail sizes
#' @param filename The file name of the .csv file containing the output
#' @param filtered_distribution Does the p-values have to be computed using filtered distribution
#' or normal distribution (filtered distribution by default)
#' @param sep The separator used in the csv file (';' by default)
#' @export
p_value_csv_file <- function(distribution_outputs, filename, filtred_distribution = TRUE, sep = ";") {
    invisible(.Call(`_emcAdr_p_value_csv_file`, distribution_outputs, filename, filtred_distribution, sep))
}

#' Function used to convert your genetic algorithm results that are stored into 
#' a .csv file to a Data structure that can be used by the clustering algorithm
#' @param ATC_name the ATC_name column of the ATC tree
#' @param filename Name of the file where the results are located
#' @param sep the separator to use when opening the csv file (';' by default)
#' @return An R List that can be used by other algorithms (e.g. clustering algorithm)
#' @export
csv_to_population <- function(ATC_name, filename, sep = ";") {
    .Call(`_emcAdr_csv_to_population`, ATC_name, filename, sep)
}

#' Function used to convert a string vector of drugs in form "drug1:drug2" to 
#' a vector of index of the ATC tree ex: c(ATC_index(drug1), ATC_index(drugs2))
#' @param ATC_name the ATC_name column of the ATC tree
#' @param lines A string vector of drugs cocktail in the form "drug1:drug2:...:drug_n"
#' @return An R List that can be used by other algorithms (e.g. clustering algorithm)
#' @export
string_list_to_int_cocktails <- function(ATC_name, lines) {
    .Call(`_emcAdr_string_list_to_int_cocktails`, ATC_name, lines)
}

#' Function used to convert integer cocktails (like the one outputed by the distributionApproximation function)
#' to string cocktail in order to make them more readable
#' 
#' @param cocktails cocktails vector to be converted (index in the ATC tree)
#' @param ATC_name The ATC_name column of the ATC tree
#' 
#' @return The name of integer cocktails in cocktails
#' @export
int_cocktail_to_string_cocktail <- function(cocktails, ATC_name) {
    .Call(`_emcAdr_int_cocktail_to_string_cocktail`, cocktails, ATC_name)
}

#'The true distribution of the score among every single nodes of the ATC
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
NULL

#'Function used to compare diverse metrics used in Disproportionality analysis
NULL

#'The MCMC method that runs the random walk on a single cocktail in order to estimate the distribution of score among cocktails of size Smax.
#'
#'@param epochs : number of steps for the MCMC algorithm
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root, also see on the github repo for an example)
#'@param observations : real observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'
#'@param temperature : starting temperature, default = 1 (denoted T in the article)
#'@param nbResults : Number of returned solution (Cocktail of size Smax with the best oberved score during the run), 5 by default
#'@param Smax : Size of the cocktail we approximate the distribution from
#'@param p_type1: probability to operate type1 mutation. Note :
#'the probability to operate the type 2 mutation is then 1 - P_type1. P_type1 must be in [0;1]. Default is .01
#'@param beta : filter the minimum number of patients that must have taken the 
#'cocktail for his risk to be taken into account in the DistributionScoreBeta default is 4
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 500
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return I no problem, return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - OutstandingScore : An array of the score greater than max_score,
#' - bestCockatils : the nbResults bests cocktails encountered during the run.
#' - bestScore : Score corresponding to the bestCocktails.
#' - FilteredDistribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - bestCocktailsBeta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - bestScoreBeta : Score corresponding to the bestCocktailsBeta.
#' - cocktailSize : Smax parameter used during the run.
#'; Otherwise the list is empty
#'@export
DistributionApproximation <- function(epochs, ATCtree, observations, temperature = 1L, nbResults = 5L, Smax = 2L, p_type1 = .01, beta = 4L, max_score = 500L, num_thread = 1L, verbose = FALSE) {
    .Call(`_emcAdr_DistributionApproximation`, epochs, ATCtree, observations, temperature, nbResults, Smax, p_type1, beta, max_score, num_thread, verbose)
}

#'Genetic algorithm, trying to reach riskiest cocktails (the ones which maximize
#'the fitness function, Hypergeometric score in our case)
#'
#'@param epochs : number of step or the algorithm 
#'@param nbIndividuals : size of the population
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : real observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'@param diversity : enable the diversity mechanism of the algorithm
#' (favor the diversity of cocktail in the population),  default is false
#'@param p_crossover: probability to operate a crossover on the crossover phase. Default is 80%
#'@param p_mutation: probability to operate a mutation after the crossover phase. Default is 1%
#'@param nbElite : number of best individual we keep from generation to generation. Default is 0
#'@param tournamentSize : size of the tournament (select the best individual 
#'between tournamentSize sampled individuals) 
#'
#'@return If no problem, return a List :
#' - meanFitnesses : The mean score of the population at each epochs of the algorithm.
#' - BestFitnesses : The best score of the population at each epochs of the algorithm.
#' - FinalPopulation : The final population of the algorithm when finished (medications
#' and corresponding scores)
#'@export
GeneticAlgorithm <- function(epochs, nbIndividuals, ATCtree, observations, num_thread = 1L, diversity = FALSE, p_crossover = .80, p_mutation = .01, nbElite = 0L, tournamentSize = 2L, alpha = 1, summary = TRUE) {
    .Call(`_emcAdr_GeneticAlgorithm`, epochs, nbIndividuals, ATCtree, observations, num_thread, diversity, p_crossover, p_mutation, nbElite, tournamentSize, alpha, summary)
}

#'@param beta : minimum number of person taking the cocktails in order to consider it
#'in the beta score distribution 
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 1000
#'@param nbResults : Number of returned solution (Cocktail with the
#' best oberved score during the run), 100 by default
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return Return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - Filtered_score_distribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - Outstanding_score : An array of the score greater than max_score,
#' - Best_cocktails : the nbResults bests cocktails encountered during the run.
#' - Best_cocktails_beta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - Best_scores : Score corresponding to the Best_cocktails.
#' - Best_scores_beta : Score corresponding to the Best_cocktails_beta.
#'@export
trueDistributionDrugs <- function(ATCtree, observations, beta, max_score = 1000L, nbResults = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionDrugs`, ATCtree, observations, beta, max_score, nbResults, num_thread)
}

#'The true distribution of the score among every size-two cocktails
#'
#'@param ATCtree : ATC tree with upper bound of the DFS (without the root)
#'@param observations : observation of the AE based on the medications of each patients
#'(a DataFrame containing the medication on the first column and the ADR (boolean) on the second)
#' on which we want to compute the risk distribution
#'@param beta : minimum number of person taking the cocktails in order to consider it
#'in the beta score distribution 
#'@param max_score : maximum number the score can take. Score greater than this 
#'one would be added to the distribution as the value max_score. Default is 1000
#'@param nbResults : Number of returned solution (Cocktail with the
#' best oberved score during the run), 100 by default
#'@param num_thread : Number of thread to run in parallel if openMP is available, 1 by default
#'
#'@return Return a List containing :
#' - ScoreDistribution : the distribution of the score as an array with each cells
#' representing the number of risks =  (index-1)/ 10
#' - Filtered_score_distribution : Distribution containing score for cocktails taken by at
#' least beta patients.
#' - Outstanding_score : An array of the score greater than max_score,
#' - Best_cocktails : the nbResults bests cocktails encountered during the run.
#' - Best_cocktails_beta : the nbResults bests cocktails taken by at least beta patients
#' encountered during the run.
#' - Best_scores : Score corresponding to the Best_cocktails.
#' - Best_scores_beta : Score corresponding to the Best_cocktails_beta.
#'@export
trueDistributionSizeTwoCocktail <- function(ATCtree, observations, beta, max_score = 100L, nbResults = 100L, num_thread = 1L) {
    .Call(`_emcAdr_trueDistributionSizeTwoCocktail`, ATCtree, observations, beta, max_score, nbResults, num_thread)
}

#'Function used to compare diverse metrics used in Disproportionality analysis
#'
#'@return RR and hypergeometric score among size 3 cocktail in "cocktail"
#'@export
MetricCalc_size3 <- function(cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread = 1L) {
    .Call(`_emcAdr_MetricCalc_size3`, cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread)
}

MetricCalc_2 <- function(cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread = 1L) {
    .Call(`_emcAdr_MetricCalc_2`, cocktail, ATClength, upperBounds, observationsMedication, observationsADR, ADRCount, num_thread)
}

computeMetrics <- function(df, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_computeMetrics`, df, ATCtree, observations, num_thread)
}

computeMetrics_size3 <- function(df, ATCtree, observations, num_thread = 1L) {
    .Call(`_emcAdr_computeMetrics_size3`, df, ATCtree, observations, num_thread)
}

hyperparam_test_genetic_algorithm <- function(epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path = "./", num_thread = 1L) {
    invisible(.Call(`_emcAdr_hyperparam_test_genetic_algorithm`, epochs, nb_individuals, ATCtree, observations, nb_test_desired, mutation_rate, nb_elite, alphas, path, num_thread))
}

analyse_resultats <- function(reponses, input_filename, repetition, ATCtree) {
    invisible(.Call(`_emcAdr_analyse_resultats`, reponses, input_filename, repetition, ATCtree))
}

true_results_dissimilarity_and_class <- function(cocktails, solutions, ATCtree) {
    .Call(`_emcAdr_true_results_dissimilarity_and_class`, cocktails, solutions, ATCtree)
}

test_func <- function(ATClength) {
    .Call(`_emcAdr_test_func`, ATClength)
}

analyse_resultats_2 <- function(reponses, input_filename, repetition, ATCtree, have_solution) {
    invisible(.Call(`_emcAdr_analyse_resultats_2`, reponses, input_filename, repetition, ATCtree, have_solution))
}

#'Print every cocktail found during the genetic algorithm 
#'
#'@param input_filenames : A List containing filename of hyperparam_test_genetic_algorithm output file
#'@param ATCtree : The ATC tree
#'@param csv_filename : Name of the output file
#'
#'@export
print_csv <- function(input_filenames, observations, repetition, ATCtree, csv_filename = "solutions.csv") {
    invisible(.Call(`_emcAdr_print_csv`, input_filenames, observations, repetition, ATCtree, csv_filename))
}

get_dissimilarity_from_list <- function(genetic_results, ATCtree) {
    .Call(`_emcAdr_get_dissimilarity_from_list`, genetic_results, ATCtree)
}

get_dissimilarity <- function(filename, ATCtree, normalization = TRUE) {
    .Call(`_emcAdr_get_dissimilarity`, filename, ATCtree, normalization)
}

get_dissimilarity_from_cocktail <- function(cocktails, ATCtree, normalization = TRUE) {
    .Call(`_emcAdr_get_dissimilarity_from_cocktail`, cocktails, ATCtree, normalization)
}

get_answer_class <- function(filename, answer) {
    .Call(`_emcAdr_get_answer_class`, filename, answer)
}

